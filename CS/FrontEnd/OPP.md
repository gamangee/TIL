## 객체 지향 프로그래밍(*Object Oriented Programming)*

프로그래밍에서 필요한 데이터를 추상화시켜서 상태(속성, 어트리뷰트)와 행위(메서드)를 가진 객체로 만들고, 그 객체간의 상호 작용을 통해 로직을 구성하는 방법

객체의 공통된 특징을 추상화하여 이를 상속하고 변형하는 방식을 쓰기 때문에 코드를 재사용할 수 있는 장점이 있다. 또한 객체 단위로 코드를 분리하여 디버깅이 쉽고 유지보수가 용이하다. 하지만 객체 단위가 많아질수록 용량이 커지고, 처리 속도가 상대적으로 느리고 설계 단계에서 많은 노력과 시간이 필요하다는 단점이 있다.

### 1. 캡슐화 (Encapsulation)

- 비슷한 역할을 하는 속성(필드)과 행위(메소드)들을 하나로 묶고 접근 지정자(public, private, protected)를 통해 제어하는 것
- 외부에서 보여질 필요가 없는 데이터를 숨기면서(정보은닉) 외부에는 기능만을 제공하기 위해서도 사용한다.

### 2. 추상화 (Abstraction)

- 객체의 공통적인 속성과 기능을 추출하여 정의하는 것
- 공통 특성을 파악해 필요없는 특성을 제거하는 과정

### 3. 상속 (Inheritance)

- 하나로 대상이 되는 클래스의 모든 특징들을 물려 받는 것
- 기존 상위클래스에 기능을 가져와 재사용할 수 있으면서도 동시에 새로운 하위 클래스에 새로운 기능도 추가할 수 있는 것
- 상속관계를 맺으면 자식 객체를 생성할 때 부모 클래스의 속성들을 자동으로 물려받기 때문에 자식 클래스에서 또 정의할 필요가 없다.

### 3. 다형성 (Polymorphism)

상속을 통해 기능을 확장하거나 변경하는 것을 가능하게 해주는 것

Overriding

- 부모 클래스에서 상속받은 자식 클래스에서 부모클래스에서 만들어진 메서드를 자식 클래스에서 자신의 입맛대로 다시 재정의해서 사용하는 것

Overloading

- 같은 메서드의 이름을 쓰지만 매개변수의 개수나 데이터 타입을 다르게 적용하는 것

## 객체 지향 프로그래밍 5가지 원칙(SOLID)

구체 클래스에 의존하지 않고 추상 클래스(또는 인터페이스)에 의존함으로써 우리는 유연하고 확장가능한 애플리케이션을 만들기 위함이다.

1. 단일 책임의 원칙(SRP, Single Responsibility Principle)

`하나의 모듈 = 한 가지 책임`

모듈이 변경되는 이유가 1가지로 수정대상이 명확해지도록 구현하는 것이 목적이다.

2. 개방 폐쇄 원칙 (OCP, Open-Closed Principle)

확장에 대해 열려있고, 수정에 대해서는 닫혀있어야 한다.

변하지 않는 부분은 고정하고, 변하는 부분을 생략하여 추상화함으로써 변경이 필요한 경우에 생략된 부분만 수정하는 것이다.

3. 인터페이스 분리 원칙 (ISP, Interface segregation principle)

클라이언트의 목적과 용도에 적합한 인터페이스 만을 제공하는 것이다.

4. 리스코프 치환 원칙 (LSP, Liskov Substitution Principle)

하위 타입은 상위 타입을 대체할 수 있어야 한다

5. 의존 역전 원칙 (DIP, Dependency Inversion Principle)

추상화에 의존하며 구체화에는 의존하지 않는 설계 원칙

고수준 모듈은 저수준 모듈의 구현에 의존해서는 안 되며, 저수준 모듈이 고수준 모듈에서 정의한 추상 타입에 의존해야 한다는 것이다.

`고수준 모듈` 변경이 없는 추상화된 클래스(또는 인터페이스)

`저수준 모듈` 변하기 쉬운 구체 클래스

단, 의존성이 역전되는 시점은 컴파일 시점이다.