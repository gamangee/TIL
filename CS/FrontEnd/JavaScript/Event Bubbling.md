### ⛳ DOM Event

1. `Capturing` 이벤트가 하위 요소로 전달되는 단계
2. `Target` 이벤트가 실제 타킷 요소로 전달되는 단계
3. `Bubbling` 이벤트가 상위 요소로 전달되는 단계

### ✨ event.target vs this

`event.target` 실제 이벤트가 시작된 요소로, 버블링이 진행되어도 변하지 않는다.

`this(=event.currentTarget)` 현재 실행 중인 핸들러가 할당된 요소를 참조한다.

# 📌 Event Bubbling(이벤트 버블링)

이벤트 버블링이란? 하위 이벤트가 상위로 전달되는 과정

`정의` 특정 화면 요소에서 이벤트가 발생했을 때 해당 이벤트가 더 상위의 화면 요소들로 전달되어 가는 특성

# 📌 Event Capturing(이벤트 캡쳐링)

이벤트 캡쳐링이란? 이벤트가 발생한 지점으로 찾아 내려가는 과정

`정의` 해당 이벤트를 감지하기 위해 이벤트 버블링과 반대 방향으로 탐색하는 이벤트 전파 방식

`특징`

addEventListener 메서드의 3번째 인수로 true를 전달할 경우 캡쳐링 이벤트를 캐치할 수 있다.

반면에 false로 전달하는 경우 또는 3번째 인수를 생략하는 경우에는 타깃 단계와 버블링 단계의 이벤트만 캐치한다.

#### ⚠️ 꼭 필요한 경우를 제외하고 버블링 막지 않기!

### 💡 event.stopPropagation( )

`정의` 하나의 이벤트가 전파되는 것을 막는 메서드

`특징`

한 요소의 특정 이벤트를 처리하는 핸들러가 여러 개인 상황에서, 핸들러 중 하나가 버블링을 멈추더라도 나머지 핸들러는 여전히 동작한다.

이벤트 버블링의 경우

직접 발생한 이벤트만 발생시키고 상위 요소로 이벤트를 전달하는 것을 막는다.

이벤트 캡쳐의 경우

직접 발생한 요소의 최상위 요소 이벤트만 동작시키고 하위 요소들로 이벤트를 전달하지 않는다.

### 💡 event.stopImmediatePropagation()

`정의` 버블링을 멈추고, 요소에 할당된 다른 핸들러의 동작도 막는 메서드

`특징` 요소에 할당된 특정 이벤트를 처리하는 핸들러 모두가 동작하지 않습니다.

# 📌 Event Delegation(이벤트 위임)

`정의` 하위 요소에 각각 이벤트를 붙이지 않고 상위 요소에서 하위 요소의 이벤트들을 제어하는 방식

`장점`

다수의 이벤트 핸들러를 할당하는 대신에 하나의 이벤트 핸들러만 할당하기 때문에, 코드가 단순해지고 메모리가 절약된다.

요소를 추가하거나 제거할 때 해당 요소에 할당된 핸들러를 추가하거나 제거할 필요가 없기 때문에 코드가 짧아진다.

`단점`

이벤트 위임을 사용하기 위해 이벤트가 반드시 버블링 되어야 한다.

focus, blur, load, unload, abort, error, mouseenter, mouseleave 와 같은 이벤트는 버블링 되지 않는다.

낮은 레벨에 할당한 핸들러엔 stopPropagation()을 쓸 수 없다.
