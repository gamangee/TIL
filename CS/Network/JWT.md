# 1️⃣ HTTP

1. 웹 환경에서 사용자와 시스템 간에 데이터를 교환하기 위해 HTTP 방식을 사용한다.
2. 각각의 HTTP 통신(요청/응답)은 독립적 이기 때문에 과거의 통신(요청/응답)에 대한 내용을 전혀 알지 못한다. 매 통신마다 필요한 모든 정보를 담아서 요청을 보내야한다.
3. 사용자 인증에 대한 정보를 유지하기 위해 Session과 Cookie 또는 Token 같은 기술이 나왔다.

# 2️⃣ Cookie

`정의` 클라이언트의 로컬에 저장되는 키-값이 들어있는 작은 데이터 파일

`특징`

브라우저(클라이언트)에서 사용자 정보를 가지고 있다.

유효 시간을 지정할 수 있다.

쿠키의 유효 시간이 남을 경우 브라우저가 종료되도 스토리지에 남아있다.

`단점`

보안에 취약하다 (유출 및 조작 위험)

쿠키에는 용량 제한이 있어 많은 정보를 담을 수 없다.

웹 브라우저마다 쿠키에 대한 지원 형태가 다르기 때문에 브라우저간 공유가 불가능하다.

쿠키의 사이즈가 커질수록 네트워크에 부하가 심해진다.

# 3️⃣ Session

`정의` 클라이언트의 상태 정보를 서버 메모리에 저장하는 기술

`특징`

사용자 정보를 서버에서 저장하고 관리한다.

클라이언트는 세션ID를 쿠키에 저장한다.

세션 ID 자체는 유의미한 개인정보를 담고 있지 않는다.

`단점`

쿠키보다는 보안이 높으나 그래도 세션ID 자체 해킹의 위험이 있다.

요청이 많아지면 서버에 부하가 심해진다.

# 4️⃣ Token

`정의` 제한된 리소스에 대해 일정 기간 동안 접근 할 수 있는 권한을 캡슐화 한 것

`특징`

클라이언트에 저장되기 때문에서버의 메모리나 DB 등의 부담이 없다.

CORS 방식을 사용하기 용이하다.

`단점`

토큰 자체의 데이터 길이가 길어, 인증 요청이 많아질수록 네트워크 부하가 심해질수 있다.

Payload 자체는 암호화되지 않기 때문에 유저의 중요한 정보는 담을 수 없다.

토큰을 탈취당하면 대처하기 어렵다. (따라서 사용 기간 제한을 설정하는 식으로 극복한다)

# 5️⃣ JWT(Json Web Token)

`정의` 인증에 필요한 정보들을 암호화시킨 토큰

`방식` JWT 토큰(Access Token)을 HTTP 헤더에 실어 서버가 클라이언트를 식별

`목적` 정보 보호가 아닌, 위조 방지

`구조`

`Header` Signature을 만드는데 사용한 알고리즘, Token의 타입 정보

`Payload` 실질적으로 전달해야 하는 정보(Claim)

`Signature`

1. Header의 인코딩된 내용
2. Payload의 인코딩된 내용
3. Secret Key와 알고리즘을 이용하여 암호화된 JWT의 서명

`장점`

1. Header와 Payload를 가지고 Signature를 생성하므로 데이터 위변조를 막을 수 있다.
2. 인증 정보에 대한 별도의 저장소가 필요없다.
3. JWT는 토큰에 대한 기본 정보와 전달할 정보 및 토큰이 검증됬음을 증명하는 서명 등 필요한 모든 정보를 자체적으로 지니고 있다.
4. 클라이언트 인증 정보를 저장하는 세션과 다르게, 서버는 무상태(StateLess)가 되어 서버 확장성이 우수해질 수 있다.
5. 토큰 기반으로 다른 로그인 시스템에 접근 및 권한 공유가 가능하다. (쿠키와 차이)
6. OAuth의 경우 Facebook, Google 등 소셜 계정을 이용하여 다른 웹서비스에서도 로그인을 할 수 있다.
7. 모바일 어플리케이션 환경에서도 잘 동작한다. (모바일은 세션 사용 불가능)

`단점`

1. Self-contained : 토큰 자체에 정보를 담고 있으므로 양날의 검이 될 수 있다.
2. 정보가 많아질수록 토큰의 길이가 늘어나 네트워크에 부하를 줄 수 있다.
3. payload 자체는 암호화 된 것이 아니라 BASE64로 인코딩 된 것이기 때문에, 중간에 Payload를 탈취하여 디코딩하면 데이터를 볼 수 있으므로, payload에 중요 데이터를 넣지 않아야 한다.
4. 토큰 자체를 탈취당하면 대처하기가 어렵게 된다.
